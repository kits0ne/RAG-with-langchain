import os
import streamlit as st
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain.prompts import ChatPromptTemplate
from langchain.chains import LLMChain
from langchain.memory import ConversationBufferMemory
from langchain_community.chat_message_histories import StreamlitChatMessageHistory
import pandas as pd
import json
from datetime import datetime

# --- Configuration ---
st.set_page_config(layout="wide", page_title="Agent P√©dagogique - Donn√©es R√©elles")
st.title("üéì Agent P√©dagogique Intelligent")
st.subheader("Bas√© sur des donn√©es r√©elles de Kaggle Learn, Python Documentation et exercices pratiques")

# =============================================================================
# CHARGEMENT DES DONN√âES R√âELLES
# =============================================================================

@st.cache_data
def load_real_data():
    """Charge les donn√©es r√©elles collect√©es"""
    try:
        # Charger les formations
        if os.path.exists('formations_reelles.csv'):
            formations_df = pd.read_csv('formations_reelles.csv')
            st.success("‚úÖ Formations r√©elles charg√©es depuis formations_reelles.csv")
        else:
            st.warning("‚ö†Ô∏è Fichier formations_reelles.csv non trouv√©. Ex√©cutez d'abord le script de collecte.")
            return create_sample_data()
        
        # Charger les modules
        if os.path.exists('modules_reels.csv'):
            modules_df = pd.read_csv('modules_reels.csv')
            st.success("‚úÖ Modules r√©els charg√©s depuis modules_reels.csv")
        else:
            st.warning("‚ö†Ô∏è Fichier modules_reels.csv non trouv√©.")
            modules_df = pd.DataFrame()
        
        # Charger les exercices
        if os.path.exists('exercices_reels.json'):
            with open('exercices_reels.json', 'r', encoding='utf-8') as f:
                exercises_data = json.load(f)
            st.success("‚úÖ Exercices r√©els charg√©s depuis exercices_reels.json")
        else:
            st.warning("‚ö†Ô∏è Fichier exercices_reels.json non trouv√©.")
            exercises_data = []
        
        return formations_df, modules_df, exercises_data
    
    except Exception as e:
        st.error(f"‚ùå Erreur lors du chargement des donn√©es : {e}")
        return create_sample_data()

def create_sample_data():
    """Cr√©e des donn√©es d'exemple si les fichiers r√©els ne sont pas disponibles"""
    st.info("üìù Utilisation de donn√©es d'exemple. Pour utiliser les vraies donn√©es, ex√©cutez le script de collecte.")
    
    sample_formations = pd.DataFrame([
        {'formation_id': 1, 'titre': 'Python Basics', 'domaine': 'Programming', 'niveau': 'Beginner', 
         'duree_heures': 8, 'prerequis': 'None', 'source': 'Sample Data'},
        {'formation_id': 2, 'titre': 'Pandas Data Analysis', 'domaine': 'Data Science', 'niveau': 'Intermediate', 
         'duree_heures': 6, 'prerequis': 'Python', 'source': 'Sample Data'},
    ])
    
    sample_modules = pd.DataFrame([
        {'module_id': 1, 'formation_id': 1, 'ordre': 1, 'titre': 'Variables and Types', 
         'duree_minutes': 60, 'concepts_cles': 'int, float, string, boolean'},
        {'module_id': 2, 'formation_id': 2, 'ordre': 1, 'titre': 'DataFrame Basics', 
         'duree_minutes': 90, 'concepts_cles': 'read_csv, head, info, describe'},
    ])
    
    sample_exercises = [
        {'category': 'Python Basics', 'level': 'Beginner', 'exercises': [
            {'title': 'Hello World', 'description': 'Create a program that prints Hello World'}
        ]}
    ]
    
    return sample_formations, sample_modules, sample_exercises

# =============================================================================
# CHARGEMENT ET AFFICHAGE DES DONN√âES
# =============================================================================

# Charger les donn√©es
formations_df, modules_df, exercises_data = load_real_data()

# Initialisation session state
if "chat_history" not in st.session_state:
    st.session_state.chat_history = StreamlitChatMessageHistory()
if "generated_courses" not in st.session_state:
    st.session_state.generated_courses = []

# Configuration API
try:
    api_key = st.secrets["GEMINI_API_KEY"]
except KeyError:
    st.error("‚ùå Erreur: Cl√© 'GEMINI_API_KEY' manquante dans les secrets Streamlit.")
    st.stop()

# =============================================================================
# INTERFACE UTILISATEUR
# =============================================================================

col1, col2 = st.columns([2, 1])

with col1:
    st.write("### üí¨ G√©n√©rateur de contenu p√©dagogique")
    
    # Options de g√©n√©ration
    generation_type = st.selectbox(
        "Type de contenu √† g√©n√©rer:",
        ["Cours complet", "Module sp√©cifique", "Quiz interactif", "Exercices pratiques", "Plan de formation personnalis√©"]
    )
    
    # Filtres bas√©s sur les vraies donn√©es
    domaines_disponibles = formations_df['domaine'].unique().tolist() if not formations_df.empty else ['Programming']
    niveaux_disponibles = formations_df['niveau'].unique().tolist() if not formations_df.empty else ['Beginner']
    
    with st.expander("‚öôÔ∏è Param√®tres de g√©n√©ration"):
        col_a, col_b = st.columns(2)
        with col_a:
            domaine = st.selectbox("Domaine:", domaines_disponibles)
            niveau = st.selectbox("Niveau:", niveaux_disponibles)
        with col_b:
            duree = st.slider("Dur√©e souhait√©e (heures):", 1, 20, 6)
            format_sortie = st.selectbox("Format:", ["Texte structur√©", "JSON", "Markdown"])

with col2:
    st.write("### üìä Base de donn√©es r√©elle")
    
    # Statistiques des donn√©es
    if not formations_df.empty:
        st.metric("Formations disponibles", len(formations_df))
        st.metric("Modules document√©s", len(modules_df) if not modules_df.empty else 0)
        st.metric("Sources de donn√©es", len(formations_df['source'].unique()) if 'source' in formations_df.columns else 1)
        
        # R√©partition par source
        if 'source' in formations_df.columns:
            st.write("**R√©partition par source:**")
            source_counts = formations_df['source'].value_counts()
            for source, count in source_counts.items():
                st.write(f"‚Ä¢ {source}: {count}")
        
        # Aper√ßu des formations
        st.write("**Formations disponibles:**")
        display_cols = ['titre', 'niveau', 'duree_heures']
        if 'source' in formations_df.columns:
            display_cols.append('source')
        st.dataframe(formations_df[display_cols].head(8), use_container_width=True)
    else:
        st.warning("Aucune formation charg√©e")

# =============================================================================
# TEMPLATE POUR L'AGENT AVEC VRAIES DONN√âES
# =============================================================================

pedagogical_template_real = """
Tu es un expert p√©dagogique qui g√©n√®re des contenus de formation de haute qualit√© √† partir de tes donn√©es.

DONN√âES R√âELLES DISPONIBLES:
=== FORMATIONS ===
{formations_data}

=== MODULES D√âTAILL√âS ===
{modules_data}

=== EXERCICES PRATIQUES ===
{exercises_data}

PARAM√àTRES DE G√âN√âRATION:
- Type de contenu: {generation_type}
- Domaine: {domaine}
- Niveau: {niveau}
- Dur√©e: {duree}h
- Format: {format_sortie}

HISTORIQUE: {chat_history}

DEMANDE UTILISATEUR: {user_input}

INSTRUCTIONS SP√âCIALES:
1. Utilise tes donn√©es pour g√©n√©rer un contenu p√©dagogique pr√©cis et structur√©.
2. Cite les sources exactes (Kaggle Learn, Python Documentation, etc.)
3. Int√®gre les exercices et exemples de code fournis
4. Respecte les dur√©es r√©elles des modules
5. Mentionne les pr√©requis exacts des formations r√©elles
6. Si tu g√©n√®res un cours, base-toi sur les vrais modules de la base de donn√©es

Si tu g√©n√®res un COURS COMPLET, structure ainsi:
# titre du cours bas√© sur les vraies donn√©es

## üìã Source et informations
- **Source**: [Source exacte des donn√©es]
- **Dur√©e r√©elle**: dur√©e bas√©e sur les vraies donn√©es
- **Niveau**: niveau des vraies donn√©es
- **Pr√©requis**: pr√©requis r√©els

## üéØ Objectifs
objectifs tir√©s des donn√©es r√©elles

## üìö Programme
utilise les vrais modules avec leurs dur√©es et concepts exacts

## üíª Exercices pratiques
utilise les vrais exercices collect√©s

## üîó R√©f√©rences
- Bas√© sur les donn√©es de: sources utilis√©es

G√âN√àRE LE CONTENU:
"""

# =============================================================================
# INITIALISATION LLM
# =============================================================================

if "llm_chain_real" not in st.session_state:
    memory = ConversationBufferMemory(
        chat_memory=st.session_state.chat_history,
        memory_key="chat_history",
        input_key="user_input"
    )
    
    prompt_template = ChatPromptTemplate.from_template(pedagogical_template_real)
    llm = ChatGoogleGenerativeAI(
        model="gemini-1.5-flash-latest", 
        google_api_key=api_key, 
        temperature=0.2  # Moins cr√©atif, plus factuel
    )
    
    st.session_state.llm_chain_real = LLMChain(
        prompt=prompt_template,
        llm=llm,
        memory=memory
    )

# =============================================================================
# INTERFACE DE G√âN√âRATION
# =============================================================================

user_input = st.text_area(
    "D√©crivez le contenu p√©dagogique souhait√©:", 
    placeholder="Ex: Cr√©e un cours complet sur Python bas√© sur les donn√©es Kaggle Learn",
    height=100
)

# Boutons d'exemples avec vraies donn√©es
st.write("### üí° Exemples bas√©s sur les vraies donn√©es")
col1, col2, col3 = st.columns(3)

with col1:
    if st.button("üìö Cours Python Kaggle"):
        st.session_state.example_query = "G√©n√®re un cours complet sur Python bas√© sur les donn√©es Kaggle Learn avec tous les modules r√©els et exercices"

with col2:
    if st.button("üìä Formation Pandas"):
        st.session_state.example_query = "Cr√©e une formation Pandas en utilisant les vrais modules et exercices de la base de donn√©es"

with col3:
    if st.button("‚ùì Quiz ML r√©el"):
        st.session_state.example_query = "G√©n√®re un quiz sur Machine Learning bas√© sur les vraies le√ßons Kaggle collect√©es"

# Afficher l'exemple s√©lectionn√©
if "example_query" in st.session_state:
    user_input = st.text_area("Exemple s√©lectionn√©:", value=st.session_state.example_query, height=80, key="example_display")

# =============================================================================
# G√âN√âRATION DE CONTENU
# =============================================================================

if st.button("üöÄ G√©n√©rer le contenu avec les vraies donn√©es", type="primary"):
    if user_input:
        with st.spinner("ü§ñ G√©n√©ration bas√©e sur les donn√©es r√©elles collect√©es..."):
            try:
                # Pr√©parer le contexte avec les vraies donn√©es
                formations_context = formations_df.to_string(index=False) if not formations_df.empty else "Aucune formation charg√©e"
                modules_context = modules_df.to_string(index=False) if not modules_df.empty else "Aucun module charg√©"
                exercises_context = json.dumps(exercises_data, ensure_ascii=False, indent=2) if exercises_data else "Aucun exercice charg√©"
                
                # Filtrer les donn√©es selon les param√®tres
                filtered_formations = formations_df
                if domaine and domaine in formations_df['domaine'].values:
                    filtered_formations = formations_df[formations_df['domaine'] == domaine]
                if niveau and niveau in formations_df['niveau'].values:
                    filtered_formations = filtered_formations[filtered_formations['niveau'] == niveau]
                
                # G√©n√©rer la r√©ponse avec les vraies donn√©es
                response = st.session_state.llm_chain_real.invoke({
                    "formations_data": filtered_formations.to_string(index=False),
                    "modules_data": modules_context,
                    "exercises_data": exercises_context,
                    "generation_type": generation_type,
                    "domaine": domaine,
                    "niveau": niveau,
                    "duree": duree,
                    "format_sortie": format_sortie,
                    "user_input": user_input
                })
                
                # Afficher la r√©ponse
                st.write("### üìù Contenu g√©n√©r√© √† partir des donn√©es r√©elles:")
                st.write(response["text"])
                
                # Informations sur les sources utilis√©es
                with st.expander("üîç Sources de donn√©es utilis√©es"):
                    if not filtered_formations.empty and 'source' in filtered_formations.columns:
                        sources_used = filtered_formations['source'].unique()
                        st.write("**Sources r√©elles utilis√©es pour cette g√©n√©ration :**")
                        for source in sources_used:
                            count = len(filtered_formations[filtered_formations['source'] == source])
                            st.write(f"‚Ä¢ **{source}**: {count} formation(s)")
                    
                    st.write("**Statistiques de g√©n√©ration :**")
                    st.write(f"‚Ä¢ Formations filtr√©es: {len(filtered_formations)}")
                    st.write(f"‚Ä¢ Modules disponibles: {len(modules_df) if not modules_df.empty else 0}")
                    st.write(f"‚Ä¢ Exercices disponibles: {len(exercises_data)}")
                
                # Sauvegarder le cours g√©n√©r√©
                course_data = {
                    "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M"),
                    "type": generation_type,
                    "domaine": domaine,
                    "niveau": niveau,
                    "duree": duree,
                    "demande": user_input,
                    "contenu": response["text"],
                    "sources_utilisees": filtered_formations['source'].unique().tolist() if not filtered_formations.empty and 'source' in filtered_formations.columns else [],
                    "nb_formations_source": len(filtered_formations)
                }
                st.session_state.generated_courses.append(course_data)
                
                # Bouton de t√©l√©chargement
                filename = f"cours_reel_{datetime.now().strftime('%Y%m%d_%H%M')}"
                if format_sortie == "Markdown":
                    st.download_button(
                        "üì• T√©l√©charger (MD)",
                        response["text"],
                        file_name=f"{filename}.md",
                        mime="text/markdown"
                    )
                elif format_sortie == "JSON":
                    st.download_button(
                        "üì• T√©l√©charger (JSON)",
                        json.dumps(course_data, ensure_ascii=False, indent=2),
                        file_name=f"{filename}.json",
                        mime="application/json"
                    )
                
                st.success("‚úÖ Contenu g√©n√©r√© avec succ√®s √† partir des donn√©es r√©elles !")
                
            except Exception as e:
                st.error(f"‚ùå Erreur lors de la g√©n√©ration: {str(e)}")
                st.write("**D√©tails de l'erreur pour debugging:**")
                st.write(f"Formations disponibles: {len(formations_df) if not formations_df.empty else 0}")
                st.write(f"Modules disponibles: {len(modules_df) if not modules_df.empty else 0}")
    else:
        st.warning("‚ö†Ô∏è Veuillez saisir une demande")

# =============================================================================
# DASHBOARD DES DONN√âES R√âELLES
# =============================================================================

st.write("---")
st.write("## üìä Dashboard des donn√©es r√©elles collect√©es")

tab1, tab2, tab3 = st.tabs(["üìö Formations", "üìù Modules", "üí™ Exercices"])

with tab1:
    if not formations_df.empty:
        col1, col2 = st.columns(2)
        
        with col1:
            st.write("### R√©partition par niveau")
            if 'niveau' in formations_df.columns:
                niveau_counts = formations_df['niveau'].value_counts()
                st.bar_chart(niveau_counts)
        
        with col2:
            st.write("### R√©partition par domaine")
            if 'domaine' in formations_df.columns:
                domaine_counts = formations_df['domaine'].value_counts()
                st.bar_chart(domaine_counts)
        
        st.write("### Tableau d√©taill√© des formations")
        st.dataframe(formations_df, use_container_width=True)
    else:
        st.warning("‚ö†Ô∏è Aucune donn√©e de formation disponible")

with tab2:
    if not modules_df.empty:
        st.write("### Modules par formation")
        if 'formation_id' in modules_df.columns:
            modules_per_formation = modules_df['formation_id'].value_counts().sort_index()
            st.bar_chart(modules_per_formation)
        
        st.write("### Dur√©e moyenne des modules")
        if 'duree_minutes' in modules_df.columns:
            avg_duration = modules_df['duree_minutes'].mean()
            st.metric("Dur√©e moyenne", f"{avg_duration:.0f} minutes")
        
        st.write("### Tableau des modules")
        display_modules = modules_df[['titre', 'duree_minutes', 'concepts_cles']].head(20) if len(modules_df.columns) > 3 else modules_df.head(20)
        st.dataframe(display_modules, use_container_width=True)
    else:
        st.warning("‚ö†Ô∏è Aucune donn√©e de module disponible")

with tab3:
    if exercises_data:
        st.write("### Exercices par cat√©gorie")
        for category_data in exercises_data:
            with st.expander(f"üìÅ {category_data['category']} - {category_data['level']}"):
                st.write(f"**Nombre d'exercices:** {len(category_data['exercises'])}")
                for i, exercise in enumerate(category_data['exercises'][:3]):  # Afficher les 3 premiers
                    st.write(f"**{i+1}. {exercise['title']}**")
                    st.write(f"Description: {exercise['description']}")
                    if len(category_data['exercises']) > 3:
                        st.write(f"... et {len(category_data['exercises']) - 3} autres exercices")
    else:
        st.warning("‚ö†Ô∏è Aucun exercice disponible")

# =============================================================================
# HISTORIQUE DES G√âN√âRATIONS
# =============================================================================

if st.session_state.generated_courses:
    st.write("---")
    st.write("### üìö Historique des contenus g√©n√©r√©s (avec sources r√©elles)")
    
    for i, course in enumerate(reversed(st.session_state.generated_courses[-5:])):  # 5 derniers
        with st.expander(f"üéØ {course['type']} - {course['timestamp']} (Sources: {', '.join(course.get('sources_utilisees', ['N/A']))})"):
            col1, col2 = st.columns(2)
            
            with col1:
                st.write(f"**Domaine:** {course.get('domaine', 'N/A')}")
                st.write(f"**Niveau:** {course.get('niveau', 'N/A')}")
                st.write(f"**Dur√©e:** {course.get('duree', 'N/A')}h")
            
            with col2:
                st.write(f"**Sources utilis√©es:** {', '.join(course.get('sources_utilisees', ['N/A']))}")
                st.write(f"**Nb formations source:** {course.get('nb_formations_source', 0)}")
            
            st.write(f"**Demande:** {course['demande']}")
            st.write("**Aper√ßu du contenu g√©n√©r√©:**")
            preview = course['contenu'][:500] + "..." if len(course['contenu']) > 500 else course['contenu']
            st.text(preview)

# =============================================================================
# INSTRUCTIONS POUR R√âCUP√âRER LES DONN√âES
# =============================================================================

with st.sidebar:
    st.write("### üìã Instructions")
    
    if formations_df.empty or len(formations_df) < 5:  # Si peu de donn√©es
        st.warning("‚ö†Ô∏è Donn√©es limit√©es d√©tect√©es")
        st.write("""
        **Pour r√©cup√©rer les vraies donn√©es :**
        
        1. **Cr√©ez le fichier `collecte_donnees.py`** avec le script fourni
        
        2. **Ex√©cutez la collecte :**
        ```bash
        python collecte_donnees.py
        ```
        
        3. **Red√©marrez l'application :**
        ```bash
        streamlit run agent_pedagogique.py
        ```
        
        **Sources r√©cup√©r√©es :**
        ‚Ä¢ Kaggle Learn (Python, Pandas, ML, SQL)
        ‚Ä¢ Documentation Python officielle  
        ‚Ä¢ Exercices pratiques structur√©s
        """)
    else:
        st.success("‚úÖ Donn√©es r√©elles charg√©es")
        st.write(f"**{len(formations_df)}** formations disponibles")
        st.write("**Sources actives :**")
        if 'source' in formations_df.columns:
            for source in formations_df['source'].unique():
                st.write(f"‚Ä¢ {source}")

    st.write("---")
    st.write("### üìà Statistiques")
    st.metric("Contenus g√©n√©r√©s", len(st.session_state.generated_courses))
    if not formations_df.empty:
        st.metric("Formations disponibles", len(formations_df))
        if 'duree_heures' in formations_df.columns:
            total_hours = formations_df['duree_heures'].sum()
            st.metric("Heures de formation", f"{total_hours}h")

# Footer
st.write("---")
st.write("ü§ñ **Agent P√©dagogique avec Donn√©es R√©elles** - Bas√© sur Kaggle Learn, Python Documentation, et exercices pratiques")
st.write("üí° *G√©n√©ration automatis√©e de contenus p√©dagogiques √† partir de sources authentiques et v√©rifi√©es*")